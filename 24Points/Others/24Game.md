本来想写数独，但是一想数独的约束条件太明显，借助Python的numpy模块可能十行代码就可以结束，且扩展性不大，毕竟被限制在了9×9的棋盘上。转而关注到牌类游戏上，大部分牌类游戏都离不开排列组合，诸如德州扑克、21点等。由于时间精力限制，我选择了小时候经常玩的24点游戏。

一开始的想法就是四个1~13的随机数和+、-、×、÷以及（）的组合，若能组合出24则是问题解，其中可以考虑O(1)就能解决的情形：如四数和或者积是24的情形。但因为总组合数为7680，暴力破解穷举法并不会在几个乎特殊情形。按照这个想法，初步写了几行代码计算运算符的组合结果，如下：

```python
operator = ['+', '-', '*', '/']
operator_set = []

def operatorSet():
    for i in range(len(operator)):
        for j in range(len(operator)):
            for k in range(len(operator)):
                temp = (operator[i], operator[j], operator[k])
                operator_set.append(temp)
```

一般看到超过两个for的循环体我就会想到递归，但这里如果对数字、运算符以及括号进行组合会使得代码变得阅读性逻辑性都很差，同时也只是为了解决问题而写算法，可扩展性也很低。 

从递归分治的思路入手，本质上24点是对数的运算，不要将运算优先级或者运算符的影响过多考虑到其中，因此我需要对问题规模进行简化，若只有两个数那我对其判断能否生成24只需要进行6次判断。我想到可以对一个给定排列的任意两值先进行运算，将其值放入到原排列中与未操作元素组成新排列，这就像我们玩游戏时一般拿到四个数做的操作一样，先取两个数进行运算再看剩余元素是否能和其组合出24，相应的对三元组再次进行此操作。如此递归到四元组中元素遍历完毕，集合中元素就为初始排列能生成的所有结果，判断是否存在24。

由于递归复杂度还是很高，冗余操作也很多，故而我想到对四个数进行两两分组，分别求出两组的各种组合值，再对这两组组合值进行遍历判断，寻找生成24的值。同时还可以进行一三分组等，对于给定的一个排列，不包含∅的组合有三种。则对每一个给定排列的三种组合进行递归处理，这种方法在于处理到二元组即可以返回计算值，相比于开始的遍历效率高很多。针对三元组中重复出现的二元组也可以优化其存储结构，用字典使其无需做无用功。

和预期结果一样，采用了优化结构和动态规划的算法要比单纯递归的效率要高很多。但同时前者的扩展性却比递归法要差得多，因此我思考是否可以将动态规划优化使其具有优秀的可扩展性。问题症结在于，对问题的分类是“人为”处理的，若列出元素个数>=4的集合的所有不含∅的所有组合可以由一个函数来完成则大大满足了可扩展性，可以解决由任意N个元素运算出任意值X的问题，21Game可以升级XGame。






